"// =====================================================\n// SCORING ALGORITME v2 - ALTIJD SUGGESTIES\n// Zoekt gaten in planning, geeft altijd een voorstel\n// =====================================================\n\nconst baseData = $('Merge Calendar Data').first().json;\nconst distanceResponse = $input.first().json;\n\nconst { preferences, monteurs, calendarEventsPerMonteur, installatieDuurMinuten, config, customerAddress, deal } = baseData;\n\n// Parse reistijden van Google Maps\nconst reistijdenPerMonteur = {};\nlet minReistijd = Infinity;\nif (distanceResponse.rows && distanceResponse.status === 'OK') {\n  distanceResponse.rows.forEach((row, index) => {\n    const monteur = monteurs[index];\n    if (monteur && row.elements && row.elements[0]) {\n      const element = row.elements[0];\n      const reistijd = element.status === 'OK' ? Math.round(element.duration.value / 60) : 30;\n      reistijdenPerMonteur[monteur.id] = reistijd;\n      if (reistijd < minReistijd) minReistijd = reistijd;\n    }\n  });\n} else {\n  monteurs.forEach(m => { reistijdenPerMonteur[m.id] = 30; });\n  minReistijd = 30;\n}\n\n// Helper: Check of tijdslot beschikbaar is\nfunction isSlotAvailable(monteurId, date, startTime, durationMinutes) {\n  const events = calendarEventsPerMonteur[monteurId] || [];\n  const slotStart = new Date(`${date}T${startTime}:00`);\n  const slotEnd = new Date(slotStart.getTime() + durationMinutes * 60000);\n  for (const event of events) {\n    const eventStart = new Date(event.start.dateTime);\n    const eventEnd = new Date(event.end.dateTime);\n    if (slotStart < eventEnd && slotEnd > eventStart) return false;\n  }\n  return true;\n}\n\n// Helper: Check werkuren\nfunction isWithinWorkHours(startTime, durationMinutes, werkuren) {\n  const [startH, startM] = startTime.split(':').map(Number);\n  const startMinutes = startH * 60 + startM;\n  const endMinutes = startMinutes + durationMinutes;\n  const [werkStartH, werkStartM] = werkuren.start.split(':').map(Number);\n  const [werkEndH, werkEndM] = werkuren.eind.split(':').map(Number);\n  return startMinutes >= (werkStartH * 60 + werkStartM) && endMinutes <= (werkEndH * 60 + werkEndM);\n}\n\n// Helper: Tel werklast\nfunction getWorkload(monteurId) {\n  const events = calendarEventsPerMonteur[monteurId] || [];\n  const now = new Date();\n  const weekStart = new Date(now); weekStart.setDate(now.getDate() - now.getDay() + 1);\n  const weekEnd = new Date(weekStart); weekEnd.setDate(weekStart.getDate() + 6);\n  let jobs = 0, minutes = 0;\n  events.forEach(event => {\n    const eventDate = new Date(event.start.dateTime);\n    if (eventDate >= weekStart && eventDate <= weekEnd) {\n      jobs++;\n      minutes += (new Date(event.end.dateTime) - new Date(event.start.dateTime)) / 60000;\n    }\n  });\n  return { jobs, hours: minutes / 60 };\n}\n\n// Helper: Check of slot een gat opvult (efficiency bonus)\nfunction checksGapFilling(monteurId, date, startTime, durationMinutes) {\n  const events = calendarEventsPerMonteur[monteurId] || [];\n  const slotStart = new Date(`${date}T${startTime}:00`);\n  const slotEnd = new Date(slotStart.getTime() + durationMinutes * 60000);\n  let adjacentBefore = false, adjacentAfter = false;\n  for (const event of events) {\n    const eventStart = new Date(event.start.dateTime);\n    const eventEnd = new Date(event.end.dateTime);\n    if (Math.abs(eventEnd.getTime() - slotStart.getTime()) < 60 * 60000) adjacentBefore = true;\n    if (Math.abs(slotEnd.getTime() - eventStart.getTime()) < 60 * 60000) adjacentAfter = true;\n  }\n  return adjacentBefore || adjacentAfter ? 20 : 0;\n}\n\n// NIEUW: Zoek gaten in calendars voor alle monteurs\nfunction findCalendarGaps(referenceDate, zoekTerug, zoekVooruit) {\n  const gaps = [];\n  const refDate = new Date(referenceDate);\n  const timeSlots = ['08:00', '09:00', '10:00', '11:00', '12:00', '13:00', '14:00'];\n  \n  for (let dayOffset = -zoekTerug; dayOffset <= zoekVooruit; dayOffset++) {\n    const checkDate = new Date(refDate);\n    checkDate.setDate(refDate.getDate() + dayOffset);\n    const dayOfWeek = checkDate.getDay();\n    if (dayOfWeek === 0 || dayOfWeek === 6) continue; // Skip weekends\n    const dateStr = checkDate.toISOString().split('T')[0];\n    \n    for (const monteur of monteurs) {\n      const reistijd = reistijdenPerMonteur[monteur.id] || 30;\n      for (const timeSlot of timeSlots) {\n        if (!isWithinWorkHours(timeSlot, installatieDuurMinuten + config.bufferMinuten, monteur.werkuren)) continue;\n        if (!isSlotAvailable(monteur.id, dateStr, timeSlot, installatieDuurMinuten + config.bufferMinuten)) continue;\n        \n        const workload = getWorkload(monteur.id);\n        if (workload.jobs >= monteur.maxJobsPerWeek) continue;\n        \n        const gapBonus = checksGapFilling(monteur.id, dateStr, timeSlot, installatieDuurMinuten);\n        const reistijdScore = Math.max(0, 50 - (reistijd / 2));\n        const datumAfstand = Math.abs(dayOffset);\n        const datumScore = Math.max(0, 30 - (datumAfstand * 3));\n        const score = 100 + reistijdScore + datumScore + gapBonus;\n        \n        gaps.push({\n          date: dateStr,\n          timeSlot,\n          monteur: { id: monteur.id, naam: monteur.naam, email: monteur.email, calendarId: monteur.calendarId },\n          reistijdMinuten: reistijd,\n          workload,\n          score,\n          dayOffset,\n          isGapFiller: gapBonus > 0\n        });\n      }\n    }\n  }\n  return gaps.sort((a, b) => b.score - a.score);\n}\n\n// STAP 1: Score klant-voorkeuren\nconst scoredOptions = [];\nconst failReasons = [];\n\nfor (const preference of preferences) {\n  for (const monteur of monteurs) {\n    const reistijdMinuten = reistijdenPerMonteur[monteur.id] || 30;\n    \n    if (!isWithinWorkHours(preference.timeSlot, installatieDuurMinuten + config.bufferMinuten, monteur.werkuren)) {\n      failReasons.push({ reason: 'buiten_werkuren', preference, monteur: monteur.naam });\n      continue;\n    }\n    if (!isSlotAvailable(monteur.id, preference.date, preference.timeSlot, installatieDuurMinuten + config.bufferMinuten)) {\n      failReasons.push({ reason: 'niet_beschikbaar', preference, monteur: monteur.naam });\n      continue;\n    }\n    \n    const workload = getWorkload(monteur.id);\n    if (workload.jobs >= monteur.maxJobsPerWeek || workload.hours >= monteur.maxUrenPerWeek) {\n      failReasons.push({ reason: 'werklast_vol', preference, monteur: monteur.naam });\n      continue;\n    }\n    \n    const gapBonus = checksGapFilling(monteur.id, preference.date, preference.timeSlot, installatieDuurMinuten);\n    const reistijdPenalty = reistijdMinuten > config.softMaxReistijdMinuten ? -30 : 0;\n    const score = 100 + Math.max(0, 50 - (reistijdMinuten / 2)) + Math.max(0, 30 - (workload.jobs * 2)) + gapBonus + reistijdPenalty;\n    \n    scoredOptions.push({\n      preference,\n      monteur: { id: monteur.id, naam: monteur.naam, email: monteur.email, calendarId: monteur.calendarId },\n      reistijdMinuten,\n      workload,\n      score,\n      matchType: 'preference',\n      warning: reistijdMinuten > config.softMaxReistijdMinuten ? 'Langere reistijd dan normaal' : null\n    });\n  }\n}\n\nscoredOptions.sort((a, b) => b.score - a.score);\n\n// STAP 2: Als geen match op voorkeuren, zoek gaten\nlet matchType = 'preference';\nlet alternativeReason = null;\nlet allOptions = [...scoredOptions];\n\nif (scoredOptions.length === 0) {\n  matchType = 'alternative';\n  const refDate = preferences[0]?.date || new Date().toISOString().split('T')[0];\n  const gaps = findCalendarGaps(refDate, config.zoekDagenTerug || 3, config.zoekDagenVooruit || 7);\n  \n  if (gaps.length > 0) {\n    alternativeReason = `Uw voorkeursdatum was niet beschikbaar. Dit zijn de eerstvolgende mogelijkheden.`;\n    allOptions = gaps.map(g => ({ ...g, matchType: 'alternative' }));\n  } else {\n    // Echt niets beschikbaar - forceer suggestie met langste reistijd\n    alternativeReason = `Geen beschikbaarheid in de komende ${config.zoekDagenVooruit} dagen.`;\n  }\n}\n\n// STAP 3: Bepaal redenen voor Discord\nconst diagnostics = {\n  buitenReisgebied: minReistijd > config.softMaxReistijdMinuten,\n  buitenWerkuren: failReasons.filter(r => r.reason === 'buiten_werkuren').length > 0,\n  geenBeschikbaarheid: failReasons.filter(r => r.reason === 'niet_beschikbaar').length > 0,\n  monteurVolGeboekt: failReasons.filter(r => r.reason === 'werklast_vol').length > 0\n};\n\n// STAP 4: Bouw suggestions array\nconst suggestions = allOptions.slice(0, 5).map(opt => {\n  const [startH, startM] = opt.timeSlot ? opt.timeSlot.split(':').map(Number) : opt.preference.timeSlot.split(':').map(Number);\n  const totalMinutes = startH * 60 + startM + installatieDuurMinuten;\n  const endTime = `${String(Math.floor(totalMinutes / 60)).padStart(2, '0')}:${String(totalMinutes % 60).padStart(2, '0')}`;\n  \n  return {\n    date: opt.date || opt.preference?.date,\n    timeSlot: opt.timeSlot || opt.preference?.timeSlot,\n    endTime,\n    period: startH < 12 ? 'ochtend' : 'middag',\n    monteur: opt.monteur,\n    score: opt.score,\n    matchType: opt.matchType || matchType,\n    warning: opt.warning || (opt.reistijdMinuten > config.softMaxReistijdMinuten ? 'Langere reistijd dan normaal' : null),\n    isGapFiller: opt.isGapFiller || false\n  };\n});\n\nreturn [{\n  json: {\n    dealId: baseData.dealId,\n    contactEmail: baseData.contactEmail,\n    customerAddress,\n    deal,\n    installatieDuurMinuten,\n    config,\n    scoredOptions: allOptions,\n    besteOptie: allOptions[0] || null,\n    matchType,\n    alternativeReason,\n    diagnostics,\n    hasMatch: allOptions.length > 0,\n    hasSuggestions: suggestions.length > 0,\n    suggestions,\n    showContactButton: true,\n    totalOptionsChecked: preferences.length * monteurs.length,\n    availableOptions: allOptions.length\n  }\n}];"
